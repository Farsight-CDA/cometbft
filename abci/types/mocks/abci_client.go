// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	types "github.com/cometbft/cometbft/abci/types"
)

// ABCIClient is an autogenerated mock type for the ABCIClient type
type ABCIClient struct {
	mock.Mock
}

// ApplySnapshotChunk provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) ApplySnapshotChunk(ctx context.Context, in *types.RequestApplySnapshotChunk, opts ...grpc.CallOption) (*types.ResponseApplySnapshotChunk, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplySnapshotChunk")
	}

	var r0 *types.ResponseApplySnapshotChunk
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestApplySnapshotChunk, ...grpc.CallOption) (*types.ResponseApplySnapshotChunk, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestApplySnapshotChunk, ...grpc.CallOption) *types.ResponseApplySnapshotChunk); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseApplySnapshotChunk)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestApplySnapshotChunk, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckTx provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) CheckTx(ctx context.Context, in *types.RequestCheckTx, opts ...grpc.CallOption) (*types.ResponseCheckTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckTx")
	}

	var r0 *types.ResponseCheckTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestCheckTx, ...grpc.CallOption) (*types.ResponseCheckTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestCheckTx, ...grpc.CallOption) *types.ResponseCheckTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseCheckTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestCheckTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Commit provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) Commit(ctx context.Context, in *types.RequestCommit, opts ...grpc.CallOption) (*types.ResponseCommit, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 *types.ResponseCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestCommit, ...grpc.CallOption) (*types.ResponseCommit, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestCommit, ...grpc.CallOption) *types.ResponseCommit); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestCommit, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Echo provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) Echo(ctx context.Context, in *types.RequestEcho, opts ...grpc.CallOption) (*types.ResponseEcho, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *types.ResponseEcho
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestEcho, ...grpc.CallOption) (*types.ResponseEcho, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestEcho, ...grpc.CallOption) *types.ResponseEcho); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseEcho)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestEcho, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExtendVote provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) ExtendVote(ctx context.Context, in *types.RequestExtendVote, opts ...grpc.CallOption) (*types.ResponseExtendVote, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExtendVote")
	}

	var r0 *types.ResponseExtendVote
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestExtendVote, ...grpc.CallOption) (*types.ResponseExtendVote, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestExtendVote, ...grpc.CallOption) *types.ResponseExtendVote); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseExtendVote)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestExtendVote, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FinalizeBlock provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) FinalizeBlock(ctx context.Context, in *types.RequestFinalizeBlock, opts ...grpc.CallOption) (*types.ResponseFinalizeBlock, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FinalizeBlock")
	}

	var r0 *types.ResponseFinalizeBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestFinalizeBlock, ...grpc.CallOption) (*types.ResponseFinalizeBlock, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestFinalizeBlock, ...grpc.CallOption) *types.ResponseFinalizeBlock); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseFinalizeBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestFinalizeBlock, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Flush provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) Flush(ctx context.Context, in *types.RequestFlush, opts ...grpc.CallOption) (*types.ResponseFlush, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 *types.ResponseFlush
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestFlush, ...grpc.CallOption) (*types.ResponseFlush, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestFlush, ...grpc.CallOption) *types.ResponseFlush); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseFlush)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestFlush, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Info provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) Info(ctx context.Context, in *types.RequestInfo, opts ...grpc.CallOption) (*types.ResponseInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *types.ResponseInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestInfo, ...grpc.CallOption) (*types.ResponseInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestInfo, ...grpc.CallOption) *types.ResponseInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestInfo, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitChain provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) InitChain(ctx context.Context, in *types.RequestInitChain, opts ...grpc.CallOption) (*types.ResponseInitChain, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InitChain")
	}

	var r0 *types.ResponseInitChain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestInitChain, ...grpc.CallOption) (*types.ResponseInitChain, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestInitChain, ...grpc.CallOption) *types.ResponseInitChain); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseInitChain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestInitChain, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshots provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) ListSnapshots(ctx context.Context, in *types.RequestListSnapshots, opts ...grpc.CallOption) (*types.ResponseListSnapshots, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnapshots")
	}

	var r0 *types.ResponseListSnapshots
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestListSnapshots, ...grpc.CallOption) (*types.ResponseListSnapshots, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestListSnapshots, ...grpc.CallOption) *types.ResponseListSnapshots); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseListSnapshots)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestListSnapshots, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadSnapshotChunk provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) LoadSnapshotChunk(ctx context.Context, in *types.RequestLoadSnapshotChunk, opts ...grpc.CallOption) (*types.ResponseLoadSnapshotChunk, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadSnapshotChunk")
	}

	var r0 *types.ResponseLoadSnapshotChunk
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestLoadSnapshotChunk, ...grpc.CallOption) (*types.ResponseLoadSnapshotChunk, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestLoadSnapshotChunk, ...grpc.CallOption) *types.ResponseLoadSnapshotChunk); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseLoadSnapshotChunk)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestLoadSnapshotChunk, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OfferSnapshot provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) OfferSnapshot(ctx context.Context, in *types.RequestOfferSnapshot, opts ...grpc.CallOption) (*types.ResponseOfferSnapshot, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OfferSnapshot")
	}

	var r0 *types.ResponseOfferSnapshot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestOfferSnapshot, ...grpc.CallOption) (*types.ResponseOfferSnapshot, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestOfferSnapshot, ...grpc.CallOption) *types.ResponseOfferSnapshot); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseOfferSnapshot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestOfferSnapshot, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrepareProposal provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) PrepareProposal(ctx context.Context, in *types.RequestPrepareProposal, opts ...grpc.CallOption) (*types.ResponsePrepareProposal, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PrepareProposal")
	}

	var r0 *types.ResponsePrepareProposal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestPrepareProposal, ...grpc.CallOption) (*types.ResponsePrepareProposal, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestPrepareProposal, ...grpc.CallOption) *types.ResponsePrepareProposal); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponsePrepareProposal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestPrepareProposal, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessProposal provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) ProcessProposal(ctx context.Context, in *types.RequestProcessProposal, opts ...grpc.CallOption) (*types.ResponseProcessProposal, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProcessProposal")
	}

	var r0 *types.ResponseProcessProposal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestProcessProposal, ...grpc.CallOption) (*types.ResponseProcessProposal, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestProcessProposal, ...grpc.CallOption) *types.ResponseProcessProposal); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseProcessProposal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestProcessProposal, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) Query(ctx context.Context, in *types.RequestQuery, opts ...grpc.CallOption) (*types.ResponseQuery, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *types.ResponseQuery
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestQuery, ...grpc.CallOption) (*types.ResponseQuery, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestQuery, ...grpc.CallOption) *types.ResponseQuery); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseQuery)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestQuery, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyVoteExtension provides a mock function with given fields: ctx, in, opts
func (_m *ABCIClient) VerifyVoteExtension(ctx context.Context, in *types.RequestVerifyVoteExtension, opts ...grpc.CallOption) (*types.ResponseVerifyVoteExtension, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifyVoteExtension")
	}

	var r0 *types.ResponseVerifyVoteExtension
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestVerifyVoteExtension, ...grpc.CallOption) (*types.ResponseVerifyVoteExtension, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.RequestVerifyVoteExtension, ...grpc.CallOption) *types.ResponseVerifyVoteExtension); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ResponseVerifyVoteExtension)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.RequestVerifyVoteExtension, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewABCIClient creates a new instance of ABCIClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewABCIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ABCIClient {
	mock := &ABCIClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
